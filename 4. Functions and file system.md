## Функции и файловая система
### 1. Понятие функции
Функция в Python - объект, принимающий аргументы и возвращающий значение.  Функция должна быть связана (интегрирована) с основной программой, так сказать, со своим внешним окружением. С целью обеспечения взаимодействия с остальной частью программы для функции можно предусмотреть так называемые вход и выход.

Вход в функцию — это передача ей аргументов - данных, полученных во внешней части программы. Получив данные из своего внешнего окружения (внешней программы), функция должна их как-то обработать: выполнить некоторые действия, вычислить какое-то значение. Выход из функции — значение, вычисленное блоком кода данной функции и передаваемое во внешнюю часть программы. Входные данные называют параметрами, а выходные — возвращаемым значением. Впрочем, функция может и не принимать никаких параметров, а также ничего не возвращать. Что принимает в качестве параметров и что возвращает функция в результате своей работы, определяет программист, т. е. автор-разработчик программного кода.
Пример:
```python3
# Функция premium с двумя аргументами
def premium(salary, percent):
    result = salary * percent / 100
    return result     
```

### 2. Роль функции в программировании
Функции в языках программирования появились практически сразу вместе с первыми языками программирования. Чем же функции полезны для программиста?
В первую очередь - функции способствуют сокращению кода в программе. Например, если нам нужно выполнить одно и то же действие несколько раз в разных местах программы - то лучше всего выделить этот код в отдельную функцию. Также функции позволяют разделить код на логические составляющие. Мы можем выделить определённое сложное действие (например перемножение матриц) в отдельную функцию, чтобы оно не мешалось в коде, даже если используем её один раз за всё время выполнения программы.
### 3. Встроенные функции интерпретатора Python
Самая первая функция, которую использует программист Python - это функция print
В качестве аргументов функция print принимает любые объекты, которые выводит на экран.
Как и любая другая функция, функция print принимает аргументы, выполняет какие-то действия и возвращает результат
```python3
result = print("I'm test text")
print(result)
```
#### Функции

* __bool(x)__ - преобразование к типу bool, использующая стандартную процедуру проверки истинности. Если х является ложным или опущен, возвращает значение False, в противном случае она возвращает True.
* __bytearray([источник [, кодировка [ошибки]]])__ - преобразование к bytearray. Bytearray - изменяемая последовательность целых чисел в диапазоне 0≤X<256. Вызванная без аргументов, возвращает пустой массив байт.
* __bytes([источник [, кодировка [ошибки]]])__ - возвращает объект типа bytes, который является неизменяемой последовательностью целых чисел в диапазоне 0≤X<256. Аргументы конструктора интерпретируются как для bytearray().
* __complex([real[, imag]])__ - преобразование к комплексному числу.
* __dict([object])__ - преобразование к словарю.
* __float([X])__ - преобразование к числу с плавающей точкой. Если аргумент не указан, возвращается 0.0.
* __frozenset([последовательность])__ - возвращает неизменяемое множество.
* __int([object], [основание системы счисления])__ - преобразование к целому числу.
* __list([object])__ - создает список.
* __memoryview([object])__ - создает объект memoryview.
* __object()__ - возвращает безликий объект, являющийся базовым для всех объектов.
* __range([start=0], stop, [step=1])__ - арифметическая прогрессия от start до stop с шагом step.
* __set([object])__ - создает множество.
* __slice([start=0], stop, [step=1])__ - объект среза от start до stop с шагом step.
* __str([object], [кодировка], [ошибки])__ - строковое представление объекта. Использует метод __str__.
* __tuple(obj)__ - преобразование к кортежу.
* __abs(x)__ - Возвращает абсолютную величину (модуль числа).
* __all(последовательность)__ - Возвращает True, если все элементы истинные (или, если последовательность пуста).
* __any(последовательность)__ - Возвращает True, если хотя бы один элемент - истина. Для пустой последовательности возвращает False.
* __ascii(object)__ - Как repr(), возвращает строку, содержащую представление объекта, но заменяет не-ASCII символы на экранированные последовательности.
* __bin(x)__ - Преобразование целого числа в двоичную строку.
* __callable(x)__ - Возвращает True для объекта, поддерживающего вызов (как функции).
* __chr(x)__ - Возвращает односимвольную строку, код символа которой равен x.
* __classmethod(x)__ - Представляет указанную функцию методом класса.
* __compile(source, filename, mode, flags=0, dont_inherit=False)__ - Компиляция в программный код, который впоследствии может выполниться функцией eval или exec. Строка не должна содержать символов возврата каретки или нулевые байты.
* __delattr(object, name)__ - Удаляет атрибут с именем 'name'.
* __dir([object])__ - Список имен объекта, а если объект не указан, список имен в текущей локальной области видимости.
* __divmod(a, b)__ - Возвращает частное и остаток от деления a на b.
* __enumerate(iterable, start=0)__ - Возвращает итератор, при каждом проходе предоставляющем кортеж из номера и соответствующего члена последовательности.
* __eval(expression, globals=None, locals=None)__ - Выполняет строку программного кода.
* __exec(object[, globals[, locals]])__ - Выполняет программный код на Python.
* __filter(function, iterable)__ - Возвращает итератор из тех элементов, для которых function возвращает истину.
* __format(value[,format_spec])__ - Форматирование (обычно форматирование строки).
* __getattr(object, name ,[default])__ - извлекает атрибут объекта или default.
* __globals()__ - Словарь глобальных имен.
* __hasattr(object, name)__ - Имеет ли объект атрибут с именем 'name'.
* __hash(x)__ - Возвращает хеш указанного объекта.
* __help([object])__ - Вызов встроенной справочной системы.
* __hex(х)__ - Преобразование целого числа в шестнадцатеричную строку.
* __id(object)__ - Возвращает "адрес" объекта. Это целое число, которое гарантированно будет уникальным и постоянным для данного объекта в течение срока его существования.
* __input([prompt])__ - Возвращает введенную пользователем строку. Prompt - подсказка пользователю.
* __isinstance(object, ClassInfo)__ - Истина, если объект является экземпляром ClassInfo или его подклассом. Если объект не является объектом данного типа, функция всегда возвращает ложь.
* __issubclass(класс, ClassInfo)__ - Истина, если класс является подклассом ClassInfo. Класс считается подклассом себя.
* __iter(x)__ - Возвращает объект итератора.
* __len(x)__ - Возвращает число элементов в указанном объекте.
* __locals()__ - Словарь локальных имен.
* __map(function, iterator)__ - Итератор, получившийся после применения к каждому элементу последовательности функции function.
* __max(iter, [args ...] * [, key])__ - Максимальный элемент последовательности.
* __min(iter, [args ...] * [, key])__ - Минимальный элемент последовательности.
* __next(x)__ - Возвращает следующий элемент итератора.
* __oct(х)__ - Преобразование целого числа в восьмеричную строку.
* __open(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True)__ - Открывает файл и возвращает соответствующий поток.
* __ord(с)__ - Код символа.
* __pow(x, y[, r])__ - ( x ** y ) % r.
* __reversed(object)__ - Итератор из развернутого объекта.
* __repr(obj)__ - Представление объекта.
* __print([object, ...], *, sep=" ", end='\n', file=sys.stdout)__ - Печать.
* __property(fget=None, fset=None, fdel=None, doc=None)__
* __round(X [, N])__ - Округление до N знаков после запятой.
* __setattr(объект, имя, значение)__ - Устанавливает атрибут объекта.
* __sorted(iterable[, key][, reverse])__ - Отсортированный список.
* __staticmethod(function)__ - Статический метод для функции.
* __sum(iter, start=0)__ - Сумма членов последовательности.
* __super([тип [, объект или тип]])__ - Доступ к родительскому классу.
* __type(object)__ - Возвращает тип объекта.
* __type(name, bases, dict)__ - Возвращает новый экземпляр класса name.
* __vars([object])__ - Словарь из атрибутов объекта. По умолчанию - словарь локальных имен.
* __zip(*iters)__ - Итератор, возвращающий кортежи, состоящие из соответствующих элементов аргументов-последовательностей.
### 4. Scope (область видимости)
Вы, наверное, не раз слышали термин область видимости, когда изучали программирование. Это весьма важная тема, незнание которой может привести к достаточно запутанным ошибкам. Область видимости указывает интерпретатору, когда наименование (или переменная) видимо. Другими словами, область видимости определяет, когда и где вы можете использовать свои переменные, функции, и т.д. Если вы попытаетесь использовать что-либо, что не является в вашей области видимости, вы получите ошибку __NameError__.
Python содержит три разных типа области видимости:
* Локальная область видимости
* Глобальная область видимости
* Нелокальная область видимости (была добавлена в Python 3)

#### Локальная область видимости
Локальная область видимости наиболее часто используется в Python. Когда мы создаем переменную в блоке кода, она будет разрешена при помощи ближайшей области видимости, или областей. Группирование всех этих областей известно как среда блоков кода. Другими словами, все назначения выполняются в локальной области по умолчанию. Если вам нужно что-то другое, тогда вам нужно настроить свою переменную на глобальную или нелокальную область, которые мы рассмотрим немного позже. Сейчас мы создадим простой пример, используя интерпретатор Python, в котором демонстрируется назначение локальной области видимости.
```python3
x = 10

def my_func(a, b):
    print(x)
    print(z)

my_func(1, 2)
```
Здесь мы создаем переменную х и очень простую функцию, которая принимает два аргумента. Далее она выводит х и z. Обратите внимание на то, что мы не определили z, так что когда мы вызываем функцию, мы получаем ошибку NameError. Это происходит в связи с тем, что z не определена, или находится вне области видимости. Если вы определите z перед вызовом функции, тогда она будет найдена и ошибка NameError не возникнет. Ошибка NameError также возникает при попытке получения доступа к переменной, которая находится только внутри функции:
```python3
def my_func(a, b):
    i = 2
    print(x)

if __name__ == '__main__':
    x = 10
    my_func(1, 2)
    print(i)
```
* Что, по-вашему, должно произойти?
* Выдаст ли код цифру 10 дважды?
Нет, не выдаст. Причина в том, что мы имеем две переменные х. Переменная х внутри my_func имеет локальную область видимости функции и переопределяет переменную х вне функции. Так что когда мы вызываем функцию my_func, в выдаче мы видим 5, а не 10. Затем, когда функция возвращается, переменная х внутри функции my_func является кучей мусора и область для выдачи х срабатывает еще один раз. По этой причине последний оператор выдачи выдает именно 10. Если вы хотите кое-что поинтереснее, вы можете попытаться вывести х перед тем как назначить его в нашей функции:
```python3
def my_func(a, b):
    print(x)
    x = 5
    print(x)

if __name__ == '__main__':
    x = 10
    my_func(1, 2)
    print(x)
```
Кода вы запустите этот код, вы получите ошибку:
```python3
UnboundLocalError: local variable 'x' referenced before assignment
```
Это происходит потому, что Python замечает, что вы назначаете х в функцию my_func позже, что и приводит к ошибке, так как х еще не определен.
#### Глобальная область видимости
Python содержит оператор global. Это ключевое слово Python. Оператор global объявляет переменную доступной для блока кода, следующим за оператором. Хотя вы и можете создать наименование, перед тем, как объявить его глобальным, я настоятельно не рекомендую этого делать. Давайте попробуем использовать глобальную область для исправления нашей ошибке из предыдущего примера:
```python3
def my_func(a, b):
    global x
    print(x)
    x = 5
    print(x)

if __name__ == '__main__':
    x = 10
    my_func(1, 2)
    print(x)
```
Объявляя х как глобальный, мы говорим Python использовать первое объявление х для нашего первого оператора вывода в функции. Далее мы даем х новое значение – а именно 5, и выводим его еще раз, перед тем как выйти из функции. Обратите внимание на то, что х становится глобальной переменной, когда мы доходим до последнего оператора вывода в конце кода, и там х все еще равен 5. Давайте смешаем глобальную и локальную область видимости и поглядим, что из этого получится:
```python3
def my_func(a, b):
    global c
    b, a = a, b
    d = 'Mike'
    print(a, b, c, d)

a, b, c, d = 1, 2, 'c is global', 4
my_func(1, 2)
print(a, b, c, d)
```
Здесь мы назначаем с в качестве глобальной переменной. Таким образом, «с» будет выводиться и внутри и снаружи нашей функции. Мы также меняем местами значения переменных а и b в функции, чтобы показать, что мы можем переназначить их внутри функции, не меняя их вне функции. Это показывает, что переменные а и b не являются глобальными. Если вы запустите этот код, вы увидите следующую выдачу:
```python3
2 1 c is global Mike
1 2 c is global 4
```
Я хочу обратить ваше внимание на то, что не нужно менять глобальные переменные внутри функции. Комьюнити Python объявило такую практику очень нежелательной, так как из-за этого исправление кода становится намного сложнее. Теперь, с пониманием основных принципов локальных и глобальных областей, мы можем перейти к нелокальной области non_local.
#### Область nonlocal
В Python 3 было добавлено новое ключевое слово под названием nonlocal. С его помощью мы можем добавлять переопределение области во внутреннюю область. Вы можете ознакомиться со всей необходимой на данный счет информацией в PEP 3104. Это наглядно демонстрируется в нескольких примерах. Один из самых простых – это создание функции, которая может увеличиваться:
```python3
def counter():
    num = 0
    def incrementer():
        num += 1
        return num
    return incrementer
```
Если вы попробуете запустить этот код, вы получите ошибку UnboundLocalError, так как переменная num ссылается прежде, чем она будет назначена в самой внутренней функции. Давайте добавим nonlocal в наш код:
```python3
def counter():
    num = 0
    def incrementer():
        nonlocal num
        num += 1
        return num
    return incrementer
```
Результат работы:
```python3
c = counter()
print(c) # <function counter.<locals>.incrementer at 0x7f45caf44048>

c() # 1
c() # 2
c() # 3
```
Теперь наша возрастающая функция работает именно так, как мы от нее и ожидаем. Для заметки, тип такой функции называется closure (дословно – закрытие). Такая функция является блоком кода, который «закрывает» переменные nonlocal. Суть в том, что вы можете ссылать переменные, которые определены вне вашей функции. Обычно, nonlocal позволяет вам назначать переменные во внешней области, но не в глобальной. Так что вы не можете использовать nonlocal в функции подсчета, так как в таком случае она попытается передать функцию глобальной области. Попробуйте, и получите ошибку SyntaxError незамедлительно. Вместо этого, вам нужно использовать nonlocal во вложенной функции.
### 5. Функции
```python3
# Функция premium с двумя аргументами
def premium(salary, percent):
    result = salary * percent / 100
    return result

# Простое использование
salary = 60000
percent = 15
pay = salary + premium(salary, percent)
print(pay)

# Использование с другими переменными и значениями
new_salary = 80000
new_percent = 10
new_pay = new_salary + premium(new_salary, new_percent)
print(new_pay)

# Именованные аргументы
old_salary = 25000
old_percent = 10
old_pay = old_salary + premium(salary=old_salary, percent=old_percent)
print(old_pay)

# Функция, не возвращающая никаких значений
def useless(var1, var2):
    print("I'm useless")
    var1 = var1 ** 2 + var2 ** 2

result = useless(3, 4)
print(result)

# Пустая функция
def empty(var1, var2):
    pass

result = empty(8, 10)
print(result)

# Функция с заданными по умолчанию аргументами
def default(var1, var2=4):
    result = var1 ** 2 + var2* ** 2
    return result

result = default(1)
print(result)

# Функция с неограниченным количеством позиционных аргументов
def manyargs(var1, *args):
    print(type(args))
    print(args)

result = manyargs(4, 9, 1, 3, 3, 1)
print(result)

# Функция с неограниченным количеством именованных аргументов
def manykwargs(**kwargs):
    print(type(kwargs))
    print(kwargs)

# Хранение функций
function = premium
print(function)
result = premium(salary, percent)
print(result)
```
### 6. Передача параметров по ссылке и по значению
Как такового понятия передачи параметров по ссылке и по значению в языке Python нет. Все параметры в функции передаются по значению. Разница лишь в том, каким является передаваемый объект и как он копирует своё значение. В прошлом уроке мы говорили, что объекты могут быть изменяемыми и неизменяемыми, и к ним также можно применить то, что изменяемые объекты "передаются по ссылке", а неизменяемые - "по значению".
```python3
def function(var1):
    var1 += (8, 10)

lst = [1, 2]
function(lst)
print(lst)
tpl = (1, 2)
function(tpl)
print(tpl)
```
### 7. Генераторы (yield), итераторы (подробнее)
В прошлом уроке мы рассматривали итерируемые объекты (последовательности) и то, чем они отличаются от обычных неитерируемых объектов. Генераторы - это тоже итераторы в своём роде, по ним также можно проходится в цикле (но в отличии от списков, кортежей и словарей нельзя брать элемент по индексу)
```python3
def generator1(value):
    while value < 100:
        yield value
        value *= 2
    return "Any text"

def generator2(value):
    while value < 50:
        yield value
        value *= 2
    raise StopIteration

gen1 = generator1(10)
print(next(gen1))
print(next(gen1))
print(next(gen1))
print(next(gen1))
print(next(gen1))

gen2 = generator2(20)
print(next(gen2))
print(next(gen2))
print(next(gen2))
```
### 8. Лямбда-функции, анонимные функции
Раньше мы использовали функции, обязательно связывая их с каким-то именем. В Python есть возможность создания однострочных анонимных функций
Синтаксис:
lambda [аргументы]: [выражение]
Функция возвращает результат выражения
```python3
lmbd = lambda var1, var2, *args: set([var1, var2]) in set(args)
print(lmbd(1, 2, range(5)))
print(lmbd(8, 10, range(5)))

new_lmbd = lmbd
print(new_lmbd(8, 9, range(2)))
print(new_lmbd(7, 6, range(100)))
```
### 9. Работа с файлами и файловой системой (чтение из файла, запись в файл)
Прежде, чем работать с файлом, его надо открыть. С этим замечательно справится встроенная функция open:
```python3
f = open('text.txt', 'r')
```
У функции open много параметров, нам пока важны 3 аргумента: первый, это имя файла. Путь к файлу может быть относительным или абсолютным. Второй аргумент, это режим, в котором мы будем открывать файл.
* 'r' - открытие на чтение (является значением по умолчанию).
* 'w' - открытие на запись, содержимое файла удаляется, если файла не существует, создается новый.
* 'x' - открытие на запись, если файла не существует, иначе исключение.
* 'a' - открытие на дозапись, информация добавляется в конец файла.
* 'b' - открытие в двоичном режиме.
* 't' - открытие в текстовом режиме (является значением по умолчанию).
* '+' - открытие на чтение и запись
Режимы могут быть объединены, то есть, к примеру, 'rb' - чтение в двоичном режиме. По умолчанию режим равен 'rt'.
И последний аргумент, encoding, нужен только в текстовом режиме чтения файла. Этот аргумент задает кодировку.

#### Чтение из файла
Открыли мы файл, а теперь мы хотим прочитать из него информацию. Для этого есть несколько способов, но большого интереса заслуживают лишь два из них.
Первый - метод read, читающий весь файл целиком, если был вызван без аргументов, и n символов, если был вызван с аргументом (целым числом n).
```python3
f = open('text.txt')
f.read(1)
f.read()
```
Ещё один способ сделать это - прочитать файл построчно, воспользовавшись циклом for:
```python3
f = open('text.txt')
for line in f:
    line
```
#### Запись в файл
Теперь рассмотрим запись в файл. Попробуем записать в файл вот такой вот список:
```python3
l = [str(i)+str(i-1) for i in range(20)]

# Откроем файл на запись
f = open('text.txt', 'w')

# Запись в файл осуществляется с помощью метода write
for index in l:
    f.write(index + '\n')

# После окончания работы с файлом его обязательно нужно закрыть с помощью метода close
f.close()

# Теперь попробуем воссоздать этот список из получившегося файла. Откроем файл на чтение (надеюсь, вы поняли, как это сделать?), и прочитаем строки.
f = open('text.txt', 'r')
l = [line.strip() for line in f]
print(l)
f.close()
```
Мы получили тот же список, что и был. В более сложных случаях (словарях, вложенных кортежей и т. д.) алгоритм записи придумать сложнее. Но это и не нужно. В python уже давно придумали средства, такие как pickle или json, позволяющие сохранять в файле сложные структуры.
### 10. Практическая работа
Создать программу с меню в консоли, которая может:
* Складывать 2 числа. Оформить в виде функции, которая принимает два числа
* Вычитать из числа другое число. Оформить в виде функции, которая принимает два числа
* Умножать числа друг на друга. Оформить в виде функции, которая принимает два числа
* Делить число на другое число. Оформить в виде функции, которая принимает два числа
* Одну из предыдущих функций можно сделать в виде lambda-функции (по желанию)
* Расчёт степеней числа от 1 до бесконечности. Оформить в виде генератора, принимающего число
* Хранить историю операций
* Возможность сохранения истории операций в файл
* Возможность загрузки истории операций из файла