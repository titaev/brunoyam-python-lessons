# Встроенные типы и простейшие операции над ними
## 1. Коллекции
Классификация типов данных в Python

![Классификация типов данных в Python](images/Data type classification.png)

На прошлом уроке мы познакомились с простейшими типами данных в Python
1. Целые числа (int)
2. Числа с плаващей запятой (float)
3. Комплексные числа (complex)
4. Строки (str)
5. Массивы байт (bytearray)
6. Логический (bool)
7. NoneType
Сегодня помимо них мы изучим коллекции
1. Строка (str)
2. Список (list)
3. Кортеж (tuple)
4. Словарь (dict)
5. Множество (set)
6. Замороженное множество (frozenset)

Классификация коллекций в Python

![Классификация коллекций в Python](images/Collection type classification.png)

Коллекции классифицируются следующим образом:
1. Последовательности (sequences) - индексированные, элементы не уникальны
* Изменяемые (mutable): список
* Неизменяемые (immutable): строка, кортеж
2. Множества (sets) - неиндексированные, элементы уникальны
* Изменяемые (mutable): множество
* Неизменяемые (immutable): замороженное множество
3. Отображения (mappings) - неиндексированный набор пар ключ-значение: словарь
## 2. Последовательности (итераторы)
Последовательность - это объект, который содержит внутри себя много других объектов, которые
расположены друг за другом в определённом порядке.

Из каждой последовательности можно получить определённый объект, зная его положение в
последовательности. Для этого в языке python используется конструкция 
```python3
print(any_sequence[i])
```
__any_sequence__ - какая-то последовательность, __i__ - какое-то целое число, обозначающее индекс
(позицию) элемента.

Индексы в последовательностях нумеруются от 0 до length - 1, где length - количество элементов в
последовательности.

Пример:
```python3
string = "hello"
print(string[0])
print(string[3])
```
В изменяемых (mutable) последовательностях можно заменить один элемент последовательности на другой
```python3
lst = [1, 2, 3]
lst[1] = 5
print(lst)
```
Длину последовательности можно узнать с помощью внутренней функции __len()__
```python3
string = "hello"
print(len(string))
```
### Строки
Создать строку можно двумя способами:
* Вызвать функцию str
```python3
string = str()
```
* Заключить символы между '*', "*" или """*"""
```python3
string = ''
string = ""
string = """"""
```
При создании строки можно сразу указать, из каких символов она будет состоять
* Функция str

Между скобок можно указать любой объект - и он будет переведён в строку
```python3
string = str(5)
string = str([1, 4, 5])
string = str(True)
```
* Заключить символы между '*', "*" или """*"""
```python3
string = 'hello'
string = "hello"
string = """hello
world"""
```
Получить символ в строке, зная его позицию
```python3
string = "hello"
print(string[1])
```
Так как строка - неизменяемый тип данных, то мы не сможем заменить определённый символ в ней на
другой
```python3
string = "hello"
string[0] = "t" # Неверно
```
#### Самые интересные операции со строками
Строки можно складывать
```python3
print("hello," + " world!")
```
Строки можно умножать на целые числа
```python3
print("NO! " * 3)
```
Найти индекс подстроки в строке
```python3
string = "hello, world!"
print(string.find("ll"))
print(string.find("a"))
```
#### Таблица "Функции и методы строк"
Функция или метод	Назначение
* S = 'str'; S = "str"; S = '''str'''; S = """str""" - Литералы строк
* S = "s\np\ta\nbbb"	                             - Экранированные последовательности
* S = r"C:\temp\new"                                 - Неформатированные строки (подавляют
экранирование)
* S = b"byte"	                                     - Строка байтов
* S1 + S2                                            - Конкатенация (сложение строк)
* S1 * i                                             - Повторение строки i раз
* symbol in s                                        - Проверка, есть ли символ symbol в строке
* S[i]                                               - Обращение по индексу
* S[i:j:step]                                        - Извлечение среза
* len(S)                                             - Длина строки
* S.find(str, [start],[end])                         - Поиск подстроки в строке. Возвращает номер
первого вхождения или -1
* S.rfind(str, [start],[end])                        - Поиск подстроки в строке. Возвращает номер
последнего вхождения или -1
* S.index(str, [start],[end])                        - Поиск подстроки в строке. Возвращает номер
первого вхождения или вызывает ValueError
* S.rindex(str, [start],[end])                       - Поиск подстроки в строке. Возвращает номер
последнего вхождения или вызывает ValueError
* S.replace(шаблон, замена)                          - Замена шаблона
* S.split(символ)                                    - Разбиение строки по разделителю
* S.isdigit()                                        - Состоит ли строка из цифр
* S.isalpha()                                        - Состоит ли строка из букв
* S.isalnum()                                        - Состоит ли строка из цифр или букв
* S.islower()                                        - Состоит ли строка из символов в нижнем
регистре
* S.isupper()                                        - Состоит ли строка из символов в верхнем
регистре
* S.isspace()                                        - Состоит ли строка из неотображаемых символов
(пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'),
"горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))
* S.istitle()	                                     - Начинаются ли слова в строке с заглавной
буквы
* S.upper()	                                         - Преобразование строки к верхнему регистру
* S.lower()	                                         - Преобразование строки к нижнему регистру
* S.startswith(str)                                  - Начинается ли строка S с шаблона str
* S.endswith(str)                                    - Заканчивается ли строка S шаблоном str
* S.join(список)                                     - Сборка строки из списка с разделителем S
* ord(символ)                                        - Символ в его код ASCII
* chr(число)                                         - Код ASCII в символ
* S.capitalize()                                     - Переводит первый символ строки в верхний
регистр, а все остальные в нижний
* S.center(width, [fill])                            - Возвращает отцентрованную строку, по краям
которой стоит символ fill (пробел по умолчанию)
* S.count(str, [start],[end])                        - Возвращает количество непересекающихся
вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)
* S.expandtabs([tabsize])                            - Возвращает копию строки, в которой все
символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца.
Если TabSize не указан, размер табуляции полагается равным 8 пробелам
* S.lstrip([chars])                                  - Удаление пробельных символов в начале строки
* S.rstrip([chars])                                  - Удаление пробельных символов в конце строки
* S.strip([chars])                                   - Удаление пробельных символов в начале и в
конце строки
* S.partition(шаблон)                                - Возвращает кортеж, содержащий часть перед
первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж,
содержащий саму строку, а затем две пустых строки
* S.rpartition(sep)                                  - Возвращает кортеж, содержащий часть перед
последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж,
содержащий две пустых строки, а затем саму строку
* S.swapcase()                                       - Переводит символы нижнего регистра в верхний,
а верхнего – в нижний
* S.title()                                          - Первую букву каждого слова переводит в
верхний регистр, а все остальные в нижний
* S.zfill(width)                                     - Делает длину строки не меньшей width, по
необходимости заполняя первые символы нулями
* S.ljust(width, fillchar=" ")                       - Делает длину строки не меньшей width, по
необходимости заполняя последние символы символом fillchar
* S.rjust(width, fillchar=" ")                       - Делает длину строки не меньшей width, по
необходимости заполняя первые символы символом fillchar
* S.format(*args, **kwargs)                          - Форматирование строки
### Списки
Создать список можно двумя способами:
* Вызывать функцию list()
```python3
lst = list()
```
* Использовать квадратные скобки
```python3
lst = []
```
При создании списка можно сразу указать, из каких элементов он будет состоять
* Функция list
Между скобок можно указать любую последовательность - и на её основе будет сделан список
```python3
lst = list([1, 4, 5])
lst = list("hello")
```
* Использовать квадратные скобки
```python3
lst = ["h", 1, 3.5, True, None]
```
Получить элемент последовательности, зная его позицию
```python3
lst = [4, 3, 2, 1]
print(lst[1])
```
Так как список - изменяемый тип данных, то мы можем заменить определённый элемент в нём на другой
```python3
lst = [4, 3, 2, 1]
lst[0] = 8
```
#### Самые интересные операции со списками
Списки можно складывать
```python3
print([1, 2] + [3, 4])
```
Списки можно умножать на целые числа
```python3
print([1, 2] * 3)
```
Найти индекс элемента в списке
```python3
lst = [1, 2, 3, 4, 5, 6, 7]
print(lst.index(4))
print(lst.index(10))
```
#### Таблица "Функции и методы списков"
* lst1 + lst2                               Сложение списков - второй список прибавляется к первому
* lst1 * i                                  Повторение списка i раз
* elem in lst                               Проверка, есть ли элемент elem в списке lst
* lst[i]                                    Обращение по индексу
* lst[i:j:step]                             Извлечение среза
* len(lst)                                  Длина списка
* lst.append(x)                             Добавляет элемент в конец списка
* lst.extend(L)	                            Расширяет список list, добавляя в конец все элементы
списка L
* lst.insert(i, x)                          Вставляет на i-ый элемент значение x
* lst.remove(x)                             Удаляет первый элемент в списке, имеющий значение x.
ValueError, если такого элемента не существует
* lst.pop([i])                              Удаляет i-ый элемент и возвращает его. Если индекс не
указан, удаляется последний элемент
* lst.index(x, [start [, end]])             Возвращает положение первого элемента со значением x
(при этом поиск ведется от start до end)
* lst.count(x)                              Возвращает количество элементов со значением x
* lst.sort([key=функция, reverse=False])    Сортирует список на основе функции
* lst.reverse()                             Разворачивает список
* lst.copy()                                Поверхностная копия списка
* lst.clear()                               Очищает список
Нужно отметить, что методы списков, в отличие от строковых методов, изменяют сам список, а потому
результат выполнения не нужно записывать в эту переменную.
```python3
lst = [3, 1, 6, 4, 0]
lst.sort()
print(lst)
lst = lst.sort()
print(lst)
```
### Кортежи
Создать кортеж можно двумя способами:
* Вызывать функцию tuple()
```python3
tpl = tuple()
```
* Использовать круглые скобки с запятой внутри
```python3
tuple = (,)
```
При создании кортежа можно сразу указать, из каких элементов он будет состоять
* Функция tuple
Между скобок можно указать любую последовательность - и на её основе будет сделан кортеж
```python3
tpl = tuple([1, 4, 5])
tpl = tuple("hello")
```
* Использовать квадратные скобки
```python3
tpl = ("h", 1, 3.5, True, None)
```
Получить элемент последовательности, зная его позицию
```python3
tpl = (4, 3, 2, 1)
print(tpl[1])
```
Так как кортеж - неизменяемый тип данных, то мы не можем заменить определённый элемент в нём на
другой
```python3
tpl = (4, 3, 2, 1)
tpl[0] = 8 # Неправильно
```
#### Зачем нужны кортежи, если есть списки?
* Защита от дурака. То есть кортеж защищен от изменений, как намеренных (что плохо), так и случайных
(что хорошо).
* Меньший размер. Дабы не быть голословным:
```python3
a = (1, 2, 3, 4, 5, 6)
b = [1, 2, 3, 4, 5, 6]
a.__sizeof__()
b.__sizeof__()
```
#### Самые интересные операции с кортежами
Кортежи можно складывать
```python3
print((1, 2) + (3, 4))
```
Кортежи можно умножать на целые числа
```python3
print((1, 2) * 3)
```
Найти индекс элемента в кортеже
```python3
tpl = (1, 2, 3, 4, 5, 6, 7)
print(tpl.index(4))
print(tpl.index(10))
```
Например, гордость программистов Python - поменять местами значения двух переменных:
```python3
a, b = b, a
```
#### Таблица "Функции и методы кортежей"
* tpl1 + tpl2                               Сложение кортежей - второй кортеж прибавляется к первому
* tpl * i                                   Повторение кортежа i раз
* elem in tpl                               Проверка, есть ли элемент elem в кортеже
* tpl[i]                                    Обращение по индексу
* tpl[i:j:step]                             Извлечение среза
* len(tpl)                                  Длина кортежа
* tpl.index(x, [start [, end]])             Возвращает положение первого элемента со значением x
(при этом поиск ведется от start до end)
* tpl.count(x)                              Возвращает количество элементов со значением x
### Отличие последовательностей от обычного объекта
#### Протокол итераций
Чтобы объект можно было назвать последовательностью, он должен обладать некоторыми свойствами.
Для того, чтобы объект можно было использовать как последовательность он должен иметь метод
**\_\_iter\_\_**, который возвращает итератор. Объект итератора же в свою очередь должен иметь метод
**\_\_next\_\_**, который при каждом новом вызове возвращает следующий элемент последовательности.

Пример:
```python3
lst = [8, 2, 5, 4]
it = lst.__iter__() # Получение итератора
it.__next__()       # Получение следующего элемента
it.__next__()       # Получение следующего элемента
it.__next__()       # Получение следующего элемента
it.__next__()       # Получение следующего элемента
it.__next__()       # Получение следующего элемента
```
Когда последовательность закончена, метод **\_\_next\_\_** выбрасывает исключение StopIteration
Так как Python позиционирует себя как лаконичный язык, в языке есть такие функции как **iter** и
**next**, которые делают вызовы методов **\_\_iter\_\_** и **\_\_next\_\_** более красивыми
Пример:
```python3
lst = [12, 54, 11, 67]
it = iter(lst)
next(it)
next(it)
next(it)
next(it)
next(it)
```
### Отрицательные индексы
У каждой последовательности мы можем получить определённый элемент, если укажем его индекс в
квадратных скобках. Если укажем число, которое равно или больше количества элементов в
последовательности, то получим ошибку.
Но если мы укажем число меньше 0, то всё равно будем получать элементы последовательности
```python3
lst = [1, 2, 3]
print(lst[0])
print(lst[-1])
```
Это сделано для нашего удобства, чтобы мы могли брать элементы, отсчитывая их не только с начала
последовательности, но и с конца. Таким образом, взяв -1 элемент - мы получим последний элемент
последовательности, взяв -2 элемент - предпоследний и так далее. Если мы возьмём __- length - 1__
элемент, где length - длина последовательности, то получим ошибку.
### Взятие среза
У каждой последовательности можно брать не только один элемент из неё, но и целую
подпоследовательность. Сделать это также можно с помощью квадратных скобок.
sqn[begin:end:step] - где __sqn__ - последовательность, __begin__ (по умолчанию 0) - индекс, с
которого начинаем брать подпоследовательность, __end__ (по умолчанию длина последовательности) -
индекс, элемент с которым уже не входит в подпоследовательность, __step__ (по умолчанию 1) - шаг, с
которым выбираем элементы для подпоследовательности.
```python3
lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(lst[1])
print(lst[1:8])
print(lst[:8])
print(lst[1:8:2])
print(lst[::2])
print(lst[8:1:-1])
print(lst[::-1])
```
В изменяемых последовательностях (списки) можно также заменять срез на другой список
```python3
lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
lst[1:4] = [20, 30]
print(lst)
```
## 3. Стек
Стек характерен тем, что получить доступ к его элементам можно лишь с одного конца, называемого
вершиной стека; иначе говоря: стек – структура данных типа «список», функционирующая по принципу
LIFO (last in — first out, «последним пришёл — первым вышел»).

![Стек](images/Stack.png)
## 4. Самостоятельная работа
На http://informatics.msk.ru показать пример выполнения задачи на задаче №2937
(https://informatics.msk.ru/mod/statements/view3.php?id=2296&chapterid=2937)
Выполнить задачи:
* №338
## 5. Множества
Множество в Python - это объект, содержащий не повторяющиеся элементы в случайном порядке.
### Множества
Множество - это изменяемый неиндексированный объект, содержащий в себе неповторяющиеся элементы
Создать множество можно двумя способами:
* Функция set
```python3
st = set()
```
* Фигурные скобки (обязательно перечислить начальные элементы)
```python3
st = {1, 2}
```
При создании множества можно сразу указать, из каких элементов оно будет состоять
* Функция set
Между скобок можно указать любую последовательность - и на её основе будет сделано множество
```python3
st = set([1, 4, 5])
st = set("hello")
```
* Использовать фигурные скобки
```python3
st = {"h", 1, 3.5, True, None}
```
#### Таблица "Функции и методы множеств"
* len(s)                                                    - число элементов в множестве (размер
множества).
* x in s                                                    - принадлежит ли x множеству s.
* set.isdisjoint(other)                                     - истина, если set и other не имеют
общих элементов.
* set == other                                              - все элементы set принадлежат other,
все элементы other принадлежат set.
* set.issubset(other) или set <= other                      - все элементы set принадлежат other.
* set.issuperset(other) или set >= other                    - аналогично.
* set.union(other, ...) или set | other | ...               - объединение нескольких множеств.
* set.intersection(other, ...) или set & other & ...        - пересечение.
* set.difference(other, ...) или set - other - ...          - множество из всех элементов set, не
принадлежащие ни одному из other.
* set.symmetric_difference(other); set ^ other              - множество из элементов, встречающихся
в одном множестве, но не встречающиеся в обоих.
* set.copy()                                                - копия множества.
* set.update(other, ...); set |= other | ...                - объединение.
* set.intersection_update(other, ...); set &= other & ...   - пересечение.
* set.difference_update(other, ...); set -= other | ...     - вычитание.
* set.symmetric_difference_update(other); set ^= other      - множество из элементов, встречающихся
в одном множестве, но не встречающиеся в обоих.
* set.add(elem)                                             - добавляет элемент в множество.
* set.remove(elem)                                          - удаляет элемент из множества.
KeyError, если такого элемента не существует.
* set.discard(elem)                                         - удаляет элемент, если он находится в
множестве.
* set.pop()                                                 - удаляет первый элемент из множества.
Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
* set.clear()                                               - очистка множества.
#### Замороженные множества
Замороженное множество - это неизменяемый неиндексированный объект, содержащий в себе
неповторяющиеся элементы
Создать замороженное множество можно следующим образом:
* Функция frozenset
```python3
frznst = frozenset()
```
При создании множества можно сразу указать, из каких элементов оно будет состоять
* Функция frozenset
Между скобок можно указать любую последовательность - и на её основе будет сделано множество
```python3
frznst = frozenset([1, 4, 5])
frznst = frozenset("hello")
```
#### Таблица "Функции и методы множеств"
* len(frzn)                                                 - число элементов в множестве (размер
множества).
* x in frzn                                                 - принадлежит ли x множеству s.
* frznst.isdisjoint(other)                                  - истина, если set и other не имеют
общих элементов.
* frznst == other                                           - все элементы set принадлежат other,
все элементы other принадлежат set.
* frznst.issubset(other) или frznst <= other                - все элементы set принадлежат other.
* frznst.issuperset(other) или frznst >= other              - аналогично.
* frznst.union(other, ...) или frznst | other | ...         - объединение нескольких множеств.
* frznst.intersection(other, ...) или frznst & other & ...  - пересечение.
* frznst.difference(other, ...) или set - other - ...       - множество из всех элементов set, не
принадлежащие ни одному из other.
* frznst.symmetric_difference(other); frznst ^ other        - множество из элементов, встречающихся
в одном множестве, но не встречающиеся в обоих.
* frznst.copy()                                             - копия множества.
## 6. Самостоятельная работа
## 7. Отображения
Из стандартных типов только словарь является отображением
### Словарь
Словарь содержит в себе структуру ключ-значение
![Ключ-значение](images/Key-value.png)
Словарь можно создать двумя способами:
* Функция dict
```python3
dct = dict()
```
* Фигурные скобки
```python3
dct = {}
```
При создании словаря можно сразу указать, из каких элементов он будет состоять
* Функция dict

Между скобок нужно указать последовательность, которая также состоит из последовательностей длиной в
2 элемента. Первый элемент будет использоваться как ключ, а второй - как значение
```python3
dct = dict((("1", 1), ("2", 2), ("3", 3)))
```
* Использовать фигурные скобки
```python3
dct = {"1": 1, "2": 2}
```
Получить значение по ключу можно с помощью квадратных скобок
```python3
dct = {"1": 1, "2": 2}
print(dct["1"])
print(dct["2"])
```
Если указать несуществующий ключ, то получим ошибку
#### Таблица "Функции и методы словарей"
* len(dct)                          - длина словаря
* dct[key]                          - взятие значение по ключу key
* dct.clear()                       - очищает словарь
* dct.copy()                        - возвращает копию словаря
* dict.fromkeys(seq[, value])       - создает словарь с ключами из seq и значением value (по
умолчанию None).
* dct.get(key[, default])           - возвращает значение ключа, но если его нет, не бросает
исключение, а возвращает default (по умолчанию None).
* dct.items()                       - возвращает пары (ключ, значение).
* dct.keys()                        - возвращает ключи в словаре.
* dct.pop(key[, default])           - удаляет ключ и возвращает значение. Если ключа нет, возвращает
default (по умолчанию бросает исключение).
* dct.popitem()                     - удаляет и возвращает пару (ключ, значение). Если словарь пуст,
бросает исключение KeyError. Помните, что словари неупорядочены.
* dct.setdefault(key[, default])    - возвращает значение ключа, но если его нет, не бросает
исключение, а создает ключ с значением default (по умолчанию None).
* dct.update([other])               - обновляет словарь, добавляя пары (ключ, значение) из other.
Существующие ключи перезаписываются. Возвращает None (не новый словарь!).
* dct.values()                      - возвращает значения в словаре.
## 8. Вложенные списки (матрицы)
Из списков, не смотря на их простую структуру, можно создавать довольно сложные и интересные
системы. В Python нет таких понятий, как массив и многомерный массив. Но здесь они и не нужны, все
базовые типы данных гибки настолько, что с помощью них можно реализовать любую привычную структуру
из других языков программирования.
### Что такое многомерные массивы?
Да, у массивов может быть несколько измерений. Конечно, на практике четырёхмерные и более массивы не
применяются совсем, так что рассматривать мы их не будем, а затронем только тему двумерных.

Что из себя представляет двумерный массив?
Самое удобная ассоциация для двумерного массива - это таблица.
Двумерный массив
![Двумерный массив](images/Two-dimensional array.jpg)
Такую же "таблицу" (а лучше всё-таки сказать массив) из чисел мы можем получить и с помощью языка
Python
```python3
matrix = [[1, 2, 3, 4, 5],
          [2, 4, 6, 8, 9],
          [3, 6, 9, 12, 15],
          [4, 8, 12, 16, 20],
          [5, 10, 15, 20, 25]]
it = iter(matrix)
print(next(it))
print(next(it))
print(next(it))
print(next(it))
```
По сути, двумерный массив - это список, состоящий из списков. Необязательно использовать именно
списки, могут подойти и кортежи, но только в том случае, если вы не собираетесь изменять элементы
матрицы/ В математике такие двумерные массивы называют матрицами, и для них есть собственная логика,
операции и прочее.
## 9. Домашнее задание
Обязательно:
* №2936 (https://informatics.msk.ru/mod/statements/view.php?id=2296)
* №2937 (https://informatics.msk.ru/mod/statements/view3.php?id=2296&chapterid=2937)
* №2938 (https://informatics.msk.ru/mod/statements/view3.php?id=2296&chapterid=2938)
* №2939 (https://informatics.msk.ru/mod/statements/view3.php?id=2296&chapterid=2939)
* №2940 (https://informatics.msk.ru/mod/statements/view3.php?id=2296&chapterid=2940)
* №292 (https://informatics.msk.ru/mod/statements/view3.php?id=276&chapterid=292)
* №253 (https://informatics.msk.ru/mod/statements/view3.php?id=276&chapterid=253)
* Прочесть Укус Питона - Глава 9
По желанию:
* На http://informatics.msk.ru обязательно решить задачи:
* * Весь раздел "Ввод-вывод" (https://informatics.msk.ru/mod/statements/view.php?id=2296)
* * Весь раздел "Условный оператор" (https://informatics.msk.ru/mod/statements/view.php?id=276)
* Прочесть Марк Лутц - Главы 7-9
