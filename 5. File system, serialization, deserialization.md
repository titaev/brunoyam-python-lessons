# Файловая система, сериализация/десериализация

## 1. Работа с файлами и файловой системой (чтение из файла, запись в файл)

### Файлы

Файлы - это просто массив байт на жёстком диске. В файлах мы можем хранить абсолютно любую
информацию: текст, аудио, видео, изображения, исполняемый код и т.д. Логически принято делить файлы
на:

1. Текстовые
2. Бинарные (двоичные)

### Действия с файлами

Работать с файлами можно тремя способами:

1. Читать из файла
2. Записывать в файл
3. Дозаписывать в файл

Прежде, чем работать с файлом, его надо открыть. С этим замечательно справится встроенная функция
open:

```python3
f = open("text.txt")
```

У функции open много параметров, нам пока важны 3 аргумента: первый, это имя файла. Путь к файлу
может быть относительным или абсолютным. Второй аргумент, это режим, __mode__, в котором мы будем
открывать файл.

* "b" - открытие в двоичном режиме.
* "t" - открытие в текстовом режиме (является значением по умолчанию).

* "r" - открытие на чтение (является значением по умолчанию).
* "w" - открытие на запись, содержимое файла удаляется, если файла не существует, создается новый.
* "x" - открытие на запись, если файла не существует, иначе исключение.
* "a" - открытие на дозапись, информация добавляется в конец файла.
* "+" - открытие на чтение и запись

Режимы могут быть объединены, то есть, к примеру, "rb" - чтение в двоичном режиме. По умолчанию
режим равен "rt". И последний аргумент, __encoding__, нужен только в текстовом режиме чтения файла.
Этот аргумент задает кодировку.

### Чтение из файла

Открыли мы файл, а теперь мы хотим прочитать из него информацию. Для этого есть несколько способов,
но большого интереса заслуживают лишь два из них. Первый - метод read, читающий весь файл целиком,
если был вызван без аргументов, и n символов, если был вызван с аргументом (целым числом n).

```python3
f = open("text.txt")
f.read(1)
f.read()
```

Ещё один способ сделать это - прочитать файл построчно, воспользовавшись циклом for:

```python3
f = open("text.txt")
for line in f:
    line
```

### Запись в файл

Теперь рассмотрим запись в файл. Попробуем записать в файл вот такой вот список:

```python3
l = [str(i) + str(i - 1) for i in range(1, 20)]

# Откроем файл на запись
f = open("text.txt", "w")

# Запись в файл осуществляется с помощью метода write
for index in l:
    f.write(index + "\n")

# После окончания работы с файлом его обязательно нужно закрыть с помощью метода close
f.close()

# Теперь попробуем воссоздать этот список из получившегося файла. Откроем файл на чтение (надеюсь,
вы поняли, как это сделать?), и прочитаем строки.
f = open("text.txt", "r")
l = [line.strip() for line in f]
print(l)
f.close()
```

### Двоичные

## 2. Оператор контекста with

Конструкция with ... as используется для оборачивания выполнения блока инструкций менеджером
контекста. Иногда это более удобная конструкция, чем try...except...finally.

Синтаксис конструкции with ... as:
```python3
with expression ["as" target] (, expression [as target])*:
    suite
```
Теперь по порядку о том, что происходит при выполнении данного блока:
1. Выполняется выражение в конструкции __with__ ... __as__.
2. Загружается специальный метод __\_\_exit\_\___ для дальнейшего использования.
3. Выполняется метод __\_\_enter\_\___. Если конструкция __with__ включает в себя слово __as__, то
возвращаемое методом __\_\_enter\_\___ значение записывается в переменную.
4. Выполняется suite.
5. Вызывается метод __\_\_exit\_\___, причём неважно, выполнилось ли suite или произошло исключение.
В этот метод передаются параметры исключения, если оно произошло, или во всех аргументах значение
None, если исключения не было.

Если в конструкции __with__ - __as__ было несколько выражений, то это эквивалентно нескольким
вложенным конструкциям:
```python3
with A() as a, B() as b:
    suite
```
эквивалентно
```python3
with A() as a:
    with B() as b:
        suite
```
Для чего применяется конструкция __with__ ... __as__? Для гарантии того, что критические функции
выполнятся в любом случае. Самый распространённый пример использования этой конструкции - открытие
файлов. Я уже рассказывал об открытии файлов с помощью функции open, однако конструкция
__with__ ... __as__, как правило, является более удобной и гарантирует закрытие файла в любом
случае. Например:

```python3
with open("newfile.txt", "w", encoding="utf-8") as f:
    d = int(input())
    f.write("1 / {} = {}".format(d, 1 / d))
```

И вы можете быть уверены, что файл будет закрыт вне зависимости от того, что введёт пользователь.

## 1. Сериализация, десериализация
Сериализация (в программировании) (англ. serialization) — процесс перевода какой-либо структуры
данных в любой другой, более удобный для хранения формат. Обратной к операции сериализации является
операция десериализации (структуризации) (англ. deserialization) — восстановление начального
состояния структуры данных из битовой последовательности.
Сериал
Самой основной структурой данных в языке программирования Python является объект. Сериализация и
десериализация объектов используется в том случае, если нам надо передавать информацию между
запусками одной программы или между несколькими программами (продуктами и прочим). Есть множество
способов сохранить/восстановить объект.
## 2. Pickle
Модуль pickle реализует мощный алгоритм сериализации и десериализации объектов Python. "Pickling" -
процесс преобразования объекта Python в поток байтов, а "unpickling" - обратная операция, в
результате которой поток байтов преобразуется обратно в Python-объект. Так как поток байтов легко
можно записать в файл, модуль pickle широко применяется для сохранения и загрузки сложных объектов в
Python.

Модуль pickle предоставляет следующие функции для удобства сохранения/загрузки объектов:
* pickle.dump(obj, file, protocol=None, *, fix_imports=True) - записывает сериализованный объект в
файл. Дополнительный аргумент protocol указывает используемый протокол. По умолчанию равен 3 и
именно он рекомендован для использования в Python 3 (несмотря на то, что в Python 3.4 добавили
протокол версии 4 с некоторыми оптимизациями). В любом случае, записывать и загружать надо с одним и
тем же протоколом.
* pickle.dumps(obj, protocol=None, *, fix_imports=True) - возвращает сериализованный объект.
Впоследствии вы его можете использовать как угодно.
* pickle.load(file, *, fix_imports=True, encoding="ASCII", errors="strict") - загружает объект из
файла.
* pickle.loads(bytes_object, *, fix_imports=True, encoding="ASCII", errors="strict") - загружает
объект из потока байт.

Модуль pickle также определяет несколько исключений:
* pickle.PickleError
* * pickle.PicklingError - случились проблемы с сериализацией объекта.
* * pickle.UnpicklingError - случились проблемы с десериализацией объекта.

Какие типы данных Pickle умеет запаковывать?
* None, True, False
* Строки (обычные или Юникод)
* Стандартные числовые типы данных
* Словари, списки, кортежи
* Функции
* Классы
Но есть одна маленькая деталь. По началу вы будете вполне довольны работой этого модуля, но позже,
когда будете его использовать на high-load проектах, начнете замечать, что консервирование данных
занимает больше времени, чем хотелось бы. Эту проблему решили тем, что был написан подобный модуль,
но уже не на Питоне, а на С, что ускорило его производительность в тысячи раз (по заявлению
разработчиков). Да, иногда модули, написанные на С, работают быстрее их питоновских аналогов, но тут
есть тонкости, в которые в этой статье я позволю себе не углубляться.

Сами создатели Питона в официальной документации советуют использовать cPickle, а чтобы долго не
модифицировать программу, можно подключить cPickle так:
```python3
import cPickle as pickle
```
Как использовать консервацию объектов? У вас есть два варианта: либо консервировать объект в строку
(которую можно передать через сокет, например) либо сразу в файл.

Есть три протокола консервации:
* Версия 0, стандартный ASCII протокол. Его следует использовать только для совместимости с ранними
версиями Питона.
* Версия 1 — примерно то же самое, используется для совместимости со старыми версиями Питона.
* Версия 2 впервые внедрена в версии 2.3, она лучше всего запаковывает объекты, написанные в
современном синтаксисе, я рекомендую использовать именно её.
Консервирование объекта в строку:
```python3
import cPickle as pickle
obj = {"one": 123, "two": [1, 2, 3]}
output = pickle.dumps(obj, 2)
```
Как видите, ничего сложного, объект готов к отправке.
Теперь нужно его распаковать назад. Это еще проще:
```python3
obj = pickle.loads(output)
```
Протокол консервирования определяется автоматически.
Давайте попробуем запаковать объект в файл.
```python3
import cPickle as pickle
obj = {"one": 123, "two": [1, 2, 3]}
output = open("data.pkl", "wb")
pickle.dump(obj, output, 2)
output.close()
```
Обратите внимание, что режим записи в файл должен обязательно быть wb, то есть перезапись файла в
бинарном режиме. Для чтения режим должен быть rb:
```python3
import cPickle as pickle
input = open("data.pkl", "rb")
obj = pickle.load(input)
input.close()
```
### 3. JSON, JSON-RPC
JSON (англ. JavaScript Object Notation) — текстовый формат обмена данными, основанный на JavaScript.
Как и многие другие текстовые форматы, JSON легко читается людьми. Формат JSON был разработан
Дугласом Крокфордом.
Для работы с форматом JSON в Python используется модуль json
```python3
import json
```
* json.dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True,
cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) - сериализует obj как
форматированный JSON поток в fp.
Если skipkeys = True, то ключи словаря не базового типа (str, unicode, int, long, float, bool, None)
будут проигнорированы, вместо того, чтобы вызывать исключение TypeError.

Если ensure_ascii = True, все не-ASCII символы в выводе будут экранированы последовательностями
\uXXXX, и результатом будет строка, содержащая только ASCII символы. Если ensure_ascii = False,
строки запишутся как есть.

Если check_circular = False, то проверка циклических ссылок будет пропущена, а такие ссылки будут
вызывать OverflowError.

Если allow_nan = False, при попытке сериализовать значение с запятой, выходящее за допустимые
пределы, будет вызываться ValueError (nan, inf, -inf) в строгом соответствии со спецификацией JSON,
вместо того, чтобы использовать эквиваленты из JavaScript (NaN, Infinity, -Infinity).

Если indent является неотрицательным числом, то массивы и объекты в JSON будут выводиться с этим
уровнем отступа. Если уровень отступа 0, отрицательный или "", то вместо этого будут просто
использоваться новые строки. Значение по умолчанию None отражает наиболее компактное представление.
Если indent - строка, то она и будет использоваться в качестве отступа.

Если sort_keys = True, то ключи выводимого словаря будут отсортированы.
* json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None,
indent=None, separators=None, default=None, sort_keys=False, **kw) - сериализует obj в строку
JSON-формата.
* json.load(fp, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None,
object_pairs_hook=None, **kw) - десериализует JSON из fp.

object_hook - опциональная функция, которая применяется к результату декодирования объекта (dict).
Использоваться будет значение, возвращаемое этой функцией, а не полученный словарь.

object_pairs_hook - опциональная функция, которая применяется к результату декодирования объекта с
определённой последовательностью пар ключ/значение. Будет использован результат, возвращаемый
функцией, вместо исходного словаря. Если задан так же object_hook, то приоритет отдаётся
object_pairs_hook.

parse_float, если определён, будет вызван для каждого значения JSON с плавающей точкой.
По умолчанию, это эквивалентно float(num_str).

parse_int, если определён, будет вызван для строки JSON с числовым значением. По умолчанию
эквивалентно int(num_str).

parse_constant, если определён, будет вызван для следующих строк: "-Infinity", "Infinity", "NaN".
Может быть использовано для возбуждения исключений при обнаружении ошибочных чисел JSON.

Если не удастся десериализовать JSON, будет возбуждено исключение ValueError.
* json.loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None,
parse_constant=None, object_pairs_hook=None, **kw) - десериализует s (экземпляр str, содержащий
документ JSON) в объект Python.
Остальные аргументы аналогичны аргументам в load().
### Кодировщики и декодировщики

Класс json.JSONDecoder(object_hook=None, parse_float=None, parse_int=None, parse_constant=None,
strict=True, object_pairs_hook=None) - простой декодер JSON.

Выполняет следующие преобразования при декодировании:

|JSON         |Python|
|-------------|------|
|object       |dict  |
|array        |list  |
|string       |str   |
|number (int) |int   |
|number (real)|float |
|true         |True  |
|false        |False |
|null         |None  |
Он также понимает NaN, Infinity, и -Infinity как соответствующие значения float, которые находятся
за пределами спецификации JSON.

Класс json.JSONEncoder(skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True,
sort_keys=False, indent=None, separators=None, default=None)

Расширяемый кодировщик JSON для структур данных Python. Поддерживает следующие объекты и типы данных
по умолчанию:

|Python	    |JSON  |
|-----------|------|
|dict       |object|
|list, tuple|array |
|str        |string|
|int, float |number|
|True       |true  |
|False      |false |
|None       |null  |
## 4. YAML
YAML (акроним англ.  «Yet Another Markup Language» — «Ещё один язык разметки», позже — рекурсивный
акроним англ. «YAML Ain't Markup Language» — «YAML — не язык разметки») — «дружественный» формат
сериализации данных, концептуально близкий к языкам разметки, но ориентированный на удобство
ввода-вывода типичных структур данных многих языков программирования.
Для работы с файлами yaml в Python используется модуль yaml.
```python3
import yaml
```
## 5. Практическая работа
Выяснить


## 13. Домашняя работа

Обязательно:

* Добавить в калькулятор возможность просмотра истории операций: аргументы, действие, результат
* Прочесть Укус Питона - Глава 10
По желанию:
* Прочесть Марк Лутц - Главы 18-20
