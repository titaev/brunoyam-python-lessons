## Хранение и передача данных
### 1. Сериализация, десериализация
Сериализация (в программировании) (англ. serialization) — процесс перевода какой-либо структуры данных в любой другой, более удобный для хранения формат. Обратной к операции сериализации является операция десериализации (структуризации) (англ. deserialization) — восстановление начального состояния структуры данных из битовой последовательности.
Сериал
Самой основной структурой данных в языке программирования Python является объект. Сериализация и десериализация объектов используется в том случае, если нам надо передавать информацию между запусками одной программы или между несколькими программами (продуктами и прочим). Есть множество способов сохранить/восстановить объект.
### 2. Pickle
Модуль pickle реализует мощный алгоритм сериализации и десериализации объектов Python. "Pickling" - процесс преобразования объекта Python в поток байтов, а "unpickling" - обратная операция, в результате которой поток байтов преобразуется обратно в Python-объект. Так как поток байтов легко можно записать в файл, модуль pickle широко применяется для сохранения и загрузки сложных объектов в Python.

Модуль pickle предоставляет следующие функции для удобства сохранения/загрузки объектов:

* pickle.dump(obj, file, protocol=None, *, fix_imports=True) - записывает сериализованный объект в файл. Дополнительный аргумент protocol указывает используемый протокол. По умолчанию равен 3 и именно он рекомендован для использования в Python 3 (несмотря на то, что в Python 3.4 добавили протокол версии 4 с некоторыми оптимизациями). В любом случае, записывать и загружать надо с одним и тем же протоколом.
* pickle.dumps(obj, protocol=None, *, fix_imports=True) - возвращает сериализованный объект. Впоследствии вы его можете использовать как угодно.
* pickle.load(file, *, fix_imports=True, encoding="ASCII", errors="strict") - загружает объект из файла.
* pickle.loads(bytes_object, *, fix_imports=True, encoding="ASCII", errors="strict") - загружает объект из потока байт.

Модуль pickle также определяет несколько исключений:
* pickle.PickleError
* * pickle.PicklingError - случились проблемы с сериализацией объекта.
* * pickle.UnpicklingError - случились проблемы с десериализацией объекта.

Какие типы данных Pickle умеет запаковывать?
* None, True, False
* Строки (обычные или Юникод)
* Стандартные числовые типы данных
* Словари, списки, кортежи
* Функции
* Классы
Но есть одна маленькая деталь. По началу вы будете вполне довольны работой этого модуля, но позже, когда будете его использовать на high-load проектах, начнете замечать, что консервирование данных занимает больше времени, чем хотелось бы. Эту проблему решили тем, что был написан подобный модуль, но уже не на Питоне, а на С, что ускорило его производительность в тысячи раз (по заявлению разработчиков). Да, иногда модули, написанные на С, работают быстрее их питоновских аналогов, но тут есть тонкости, в которые в этой статье я позволю себе не углубляться.

Сами создатели Питона в официальной документации советуют использовать cPickle, а чтобы долго не модифицировать программу, можно подключить cPickle так:
```python3
import cPickle as pickle
```
Как использовать консервацию объектов? У вас есть два варианта: либо консервировать объект в строку (которую можно передать через сокет, например) либо сразу в файл.

Есть три протокола консервации:
* Версия 0, стандартный ASCII протокол. Его следует использовать только для совместимости с ранними версиями Питона.
* Версия 1 — примерно то же самое, используется для совместимости со старыми версиями Питона.
* Версия 2 впервые внедрена в версии 2.3, она лучше всего запаковывает объекты, написанные в современном синтаксисе, я рекомендую использовать именно её.
Консервирование объекта в строку:
```python3
import cPickle as pickle
obj = {"one": 123, "two": [1, 2, 3]}
output = pickle.dumps(obj, 2)
```
Как видите, ничего сложного, объект готов к отправке.
Теперь нужно его распаковать назад. Это еще проще:
```python3
obj = pickle.loads(output)
```
Протокол консервирования определяется автоматически.
Давайте попробуем запаковать объект в файл.
```python3
import cPickle as pickle
obj = {"one": 123, "two": [1, 2, 3]}
output = open('data.pkl', 'wb')
pickle.dump(obj, output, 2)
output.close()
```
Обратите внимание, что режим записи в файл должен обязательно быть wb, то есть перезапись файла в бинарном режиме. Для чтения режим должен быть rb:
```python3
import cPickle as pickle
input = open('data.pkl', 'rb')
obj = pickle.load(input)
input.close()
```
### 3. JSON, JSON-RPC
JSON (англ. JavaScript Object Notation) — текстовый формат обмена данными, основанный на JavaScript. Как и многие другие текстовые форматы, JSON легко читается людьми. Формат JSON был разработан Дугласом Крокфордом.
Для работы с форматом JSON в Python используется модуль json
```python3
import json
```
* json.dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) - сериализует obj как форматированный JSON поток в fp.
Если skipkeys = True, то ключи словаря не базового типа (str, unicode, int, long, float, bool, None) будут проигнорированы, вместо того, чтобы вызывать исключение TypeError.

Если ensure_ascii = True, все не-ASCII символы в выводе будут экранированы последовательностями \uXXXX, и результатом будет строка, содержащая только ASCII символы. Если ensure_ascii = False, строки запишутся как есть.

Если check_circular = False, то проверка циклических ссылок будет пропущена, а такие ссылки будут вызывать OverflowError.

Если allow_nan = False, при попытке сериализовать значение с запятой, выходящее за допустимые пределы, будет вызываться ValueError (nan, inf, -inf) в строгом соответствии со спецификацией JSON, вместо того, чтобы использовать эквиваленты из JavaScript (NaN, Infinity, -Infinity).

Если indent является неотрицательным числом, то массивы и объекты в JSON будут выводиться с этим уровнем отступа. Если уровень отступа 0, отрицательный или "", то вместо этого будут просто использоваться новые строки. Значение по умолчанию None отражает наиболее компактное представление. Если indent - строка, то она и будет использоваться в качестве отступа.

Если sort_keys = True, то ключи выводимого словаря будут отсортированы.
* json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) - сериализует obj в строку JSON-формата.
* json.load(fp, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) - десериализует JSON из fp.

object_hook - опциональная функция, которая применяется к результату декодирования объекта (dict). Использоваться будет значение, возвращаемое этой функцией, а не полученный словарь.

object_pairs_hook - опциональная функция, которая применяется к результату декодирования объекта с определённой последовательностью пар ключ/значение. Будет использован результат, возвращаемый функцией, вместо исходного словаря. Если задан так же object_hook, то приоритет отдаётся object_pairs_hook.

parse_float, если определён, будет вызван для каждого значения JSON с плавающей точкой. По умолчанию, это эквивалентно float(num_str).

parse_int, если определён, будет вызван для строки JSON с числовым значением. По умолчанию эквивалентно int(num_str).

parse_constant, если определён, будет вызван для следующих строк: "-Infinity", "Infinity", "NaN". Может быть использовано для возбуждения исключений при обнаружении ошибочных чисел JSON.

Если не удастся десериализовать JSON, будет возбуждено исключение ValueError.
* json.loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) - десериализует s (экземпляр str, содержащий документ JSON) в объект Python.
Остальные аргументы аналогичны аргументам в load().
#### Кодировщики и декодировщики

Класс json.JSONDecoder(object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True, object_pairs_hook=None) - простой декодер JSON.

Выполняет следующие преобразования при декодировании:
|JSON         |Python|
|-------------|------|
|object       |dict  |
|array        |list  |
|string       |str   |
|number (int) |int   |
|number (real)|float |
|true         |True  |
|false        |False |
|null         |None  |
Он также понимает NaN, Infinity, и -Infinity как соответствующие значения float, которые находятся за пределами спецификации JSON.

Класс json.JSONEncoder(skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)

Расширяемый кодировщик JSON для структур данных Python. Поддерживает следующие объекты и типы данных по умолчанию:
|Python	    |JSON  |
|-----------|------|
|dict       |object|
|list, tuple|array |
|str        |string|
|int, float |number|
|True       |true  |
|False      |false |
|None       |null  |
### 4. YAML
YAML (акроним англ.  «Yet Another Markup Language» — «Ещё один язык разметки», позже — рекурсивный акроним англ. «YAML Ain't Markup Language» — «YAML — не язык разметки») — «дружественный» формат сериализации данных, концептуально близкий к языкам разметки, но ориентированный на удобство ввода-вывода типичных структур данных многих языков программирования.
Для работы с файлами yaml в Python используется модуль yaml.
```python3
import yaml
```
### 5. Практическая работа
```python3
class Class:
    static = "static"

    def __init__(self):
        self.dynamic = "dynamic"

obj = Class()

dictionary = {
    "string": "string",
    "int": 80,
    "float": 34.5,
    "list": ["field1", 2, 3.75, "field4"],
    "tuple": ("field1", 2, 3.75, "field4"),
    "set": {"field1", 2, 3.75, "field4"},
}

# Имея 3 объекта (Class, obj, dictionary), вывести их на экран и  сериализовать (сохранить) их с помощью pickle, json, yaml в файлы "test.pk", "test.json", "test.yml" соответственно.
# После загрузить их из файлов и вывести на экран.
```