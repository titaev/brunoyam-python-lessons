# Процессы и потоки
## 1. Общие понятия
Процесс – это исполняемая копия приложения. Например, когда вы открываете приложение MS Word, то запускаете процесс, исполняющий программу MS Word. Поток – отдельное исполняемое задание внутри процесса. Процесс может содержать множество исполняемых потоков. После запуска приложения исполняется главный поток, который далее может порождать другие потоки.

Каждый процесс обладает собственной памятью. Потоки же, которые запущены внутри процесса, разделяют память между собой. Процесс внутри операционной системы обладает собственным идентификатором. Потоки существуют внутри процесса и обладают идентификатором внутри работающего приложения. Каждый из потоков имеет свой собственный стек (он не делит его с другими потоками и другие потоки не могут в него залезть) и собственный набор регистров (поток не изменит значения регистра другого потока во время работы). Часто потоки называют «легковесными» процессами, так как они требуют гораздо меньше ресурсов для работы, чем новый процесс. В зависимости от реализации, обычный настольный компьютер может эффективно использовать от единиц, до десятков тысяч потоков.
## 2. Введение в многопоточное и мультипроцессорное программирование
## 3. Модули threading и multiprocessing
### threading
Модуль threading впервые был представлен в Python 1.5.2 как продолжение низкоуровневого модуля потоков. Модуль threading значительно упрощает работу с потоками и позволяет программировать запуск нескольких операций одновременно. Обратите внимание на то, что потоки в Python лучше всего работают с операциями I/O, такими как загрузка ресурсов из интернета или чтение файлов и папок на вашем компьютере.

Если вам нужно сделать что-то, для чего нужен интенсивный CPU, тогда вам, возможно, захочется взглянуть на модуль multiprocessing, вместо threading. Причина заключается в том, что Python содержит Global Interpreter Lock (GIL), который запускает все потоки внутри главного потока. По этой причине, когда вам нужно запустить несколько интенсивных операций с потоками, вы заметите, что все работает достаточно медленно. Так что мы сфокусируемся на том, в чем потоки являются лучшими: операции I/O.

Создадим два простых поток и проанализируем их работу
```python3
from threading import Thread
from time import sleep


def func1(start, end):
    while start < end:
        print("Func1: %s" % start)
        start += 1
        sleep(1)


def func2(start, end):
    while start < end:
        print("Func2: %s" % start)
        start += 1
        sleep(0.5)


thread1 = Thread(target=func1, args=(3, 10))
thread2 = Thread(target=func2, args=(5, 20))
thread1.start()
thread2.start()

for i in range(5):
    print("MAIN THREAD")
    sleep(0.5)

thread1.join()
thread2.join()

print("END")
```
Рассмотрим создание собственного подкласса потока
```python3
from threading import Thread
from time import sleep

class MyThread(Thread):
    def __init__(self, start, end, timeout):
        Thread.__init__(self)
        self.start = start
        self.end = end
        self.timeout = timeout

    def run(self):
        while self.start < self.end:
            print("Thread: %s" % self.start)
            self.start += 1
            sleep(self.timeout)


thread1 = MyThread(3, 10, 1)
thread2 = MyThread(5, 20, 0.5)

thread1.start()
thread2.start()

for i in range(5):
    print("MAIN THREAD")
    sleep(0.5)

thread1.join()
thread2.join()

print("END")
```
Когда у вас в распоряжении более одного потока, тогда вам, возможно, понадобится понять, как избежать конфликтов. Под этим я имею ввиду то, что вы можете использовать случай, где более одного потока нуждаются в доступе к одном и тому же ресурсу в одно и то же время. Если вы не думаете о таких проблемах и соответственном планировании, тогда вы можете столкнуться с самыми худшими проблемами в крайне неудобное время, и, как правило, в момент выпуска кода.

Решение проблемы – это использовать замки. Замок предоставлен модулем Python threading и может держать один поток, или не держать поток вообще. Если поток пытается acquire замок на ресурсе, который уже закрыт, этот поток будет ожидать до тех пор, пока замок не откроется.
Рассмотрим пример предыдущих потоков с замками
```python3
from threading import Thread, Lock
from time import sleep

class MyThread(Thread):
    def __init__(self, end, timeout):
        Thread.__init__(self)
        self.end = end
        self.timeout = timeout

    def run(self):
        while count < self.end:
            print("Thread: %s" % count)
            
            lock.aquire()
            try:
                count += 1
            finally:
                lock.release()
            
            sleep(self.timeout)


count = 0
lock = Lock()

thread1 = MyThread(10, 1)
thread2 = MyThread(20, 0.5)

thread1.start()
thread2.start()

for i in range(5):
    print("MAIN THREAD")
    sleep(0.5)

thread1.join()
thread2.join()

print("END")
```
Данную запись замка можно упростить
```python3

```

## 4. GIL
## 5. Примитивы синхронизации (мьютекс, семафор, критическая секция)
## 6. Асинхронный код